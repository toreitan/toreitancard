<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shadowverseé¢¨ã‚«ãƒ¼ãƒ‰ã‚²ãƒ¼ãƒ </title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .card {
      width: 150px;
      height: 220px;
      border: 2px solid #000;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 10px;
      background: white;
      cursor: pointer;
      user-select: none;
      font-size: 14px;
    }
    .mulligan-card {
      width: 80px;
      height: 117px;
      font-size: 10px;
      padding: 5px;
    }
    .mulligan-card .card-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .card.dragging {
      opacity: 0.8;
    }
    .card.attackable:hover {
      border-color: #ff0000;
      transform: scale(1.05);
    }
    .card.attacked {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .card.guard {
      border-color: #1e90ff;
      background: linear-gradient(to bottom, #e6f3ff, #b3d9ff);
      position: relative;
    }
    .card.guard::before {
      content: "ğŸ›¡ï¸";
      position: absolute;
      top: 4px;
      right: 4px;
      font-size: 12px;
    }
    .card.selected {
      border-color: #ff8c00;
      background: linear-gradient(to bottom, #fff7e6, #ffdab9);
    }
    .play-area {
      min-height: 240px;
      border: 2px dashed #666;
    }
    .card.effect {
      background: linear-gradient(to bottom, #f0f8ff, #e6e6fa);
    }
    .drop-target:hover {
      border: 2px dashed #ff0000;
    }
    #game-result, #mulligan-screen, #card-detail-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #game-result.show, #mulligan-screen.show, #card-detail-modal.show {
      display: flex;
    }
    #game-result div {
      background: white;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      max-width: 500px;
      width: 90%;
    }
    #mulligan-screen div {
      background: white;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      max-width: 600px;
      width: 90%;
    }
    #mulligan-cards {
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      gap: 8px;
      justify-content: center;
      margin-bottom: 16px;
      max-width: 480px;
    }
    .tooltip {
      position: relative;
    }
    .tooltip:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 110%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: white;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 8px;
      white-space: nowrap;
      z-index: 30;
    }
    #card-detail-modal div {
      background: white;
      padding: 16px;
      border-radius: 8px;
      text-align: left;
      max-width: 300px;
      width: 90%;
      font-size: 16px;
      position: relative;
    }
    .close-button {
      position: absolute;
      top: 8px;
      right: 8px;
      font-size: 20px;
      cursor: pointer;
      color: #333;
    }
    .close-button:hover {
      color: #ff0000;
    }
  </style>
</head>
<body class="bg-gray-100 flex flex-col items-center py-4">
  <h1 class="text-3xl font-bold mb-4">Shadowverse: ãƒŸãƒ‹ã‚²ãƒ¼ãƒ </h1>
  <div id="game-status" class="mb-4 text-lg font-semibold"></div>
  <div class="flex w-full max-w-5xl mx-auto">
    <div id="player-info" class="w-1/4 p-4 bg-green-100 rounded-lg mr-2">
      <h2 class="text-xl font-semibold">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</h2>
      <p id="player-mana">ãƒãƒŠ: 0/0</p>
      <p id="player-life">ãƒ©ã‚¤ãƒ•: 20</p>
    </div>
    <div id="ai-info" class="w-1/4 p-4 bg-blue-100 rounded-lg mr-2 drop-target">
      <h2 class="text-xl font-semibold">AI</h2>
      <p id="ai-mana">ãƒãƒŠ: 0/0</p>
      <p id="ai-life">ãƒ©ã‚¤ãƒ•: 20</p>
    </div>
    <div id="play-area" class="w-1/2 p-4 bg-gray-200 rounded-lg play-area">
      <h2 class="text-xl font-semibold">ãƒ—ãƒ¬ã‚¤ã‚¨ãƒªã‚¢</h2>
      <div id="ai-field" class="flex flex-wrap gap-2 mb-2 border-b-2 border-gray-400 pb-2 drop-target"></div>
      <div id="player-field" class="flex flex-wrap gap-2"></div>
    </div>
  </div>
  <div id="player-hand" class="w-full max-w-5xl mx-auto p-4 bg-green-200 rounded-lg mt-4">
    <h2 class="text-xl font-semibold">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­</h2>
    <div id="player-cards" class="flex flex-wrap gap-2"></div>
  </div>
  <button id="end-turn" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
  <div id="game-result">
    <div>
      <h2 id="result-text" class="text-2xl font-bold mb-4"></h2>
      <button id="reset-button" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600">ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
  </div>
  <div id="mulligan-screen">
    <div>
      <h2 class="text-2xl font-bold mb-6">æ‰‹æœ­ã‚’é¸æŠã—ã¦ãã ã•ã„</h2>
      <div id="mulligan-cards"></div>
      <button id="mulligan-confirm" class="mt-6 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">ãƒãƒªã‚¬ãƒ³ç¢ºå®š</button>
    </div>
  </div>
  <div id="card-detail-modal">
    <div>
      <span id="close-detail" class="close-button">Ã—</span>
      <div id="card-detail-content"></div>
    </div>
  </div>

  <script>
    // ãƒ©ãƒ³ãƒ€ãƒ ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    const classes = ["ãƒ•ã‚©ãƒ¬ã‚¹ãƒˆã‚¯ãƒ©ãƒ•ãƒˆ", "ã‚½ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒ•ãƒˆ", "ãƒ«ãƒ¼ãƒ³ã‚¯ãƒ©ãƒ•ãƒˆ", "ãƒ‰ãƒ©ã‚´ãƒ³ã‚¯ãƒ©ãƒ•ãƒˆ", "ã‚¢ãƒ“ã‚¹ã‚¯ãƒ©ãƒ•ãƒˆ", "ãƒãƒ´ãƒ³ã‚¯ãƒ©ãƒ•ãƒˆ", "ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«"];
    const prefixes = ["ãƒã‚¸ãƒƒã‚¯", "ãƒ–ãƒ¬ã‚¤ãƒ–", "ãƒ€ãƒ¼ã‚¯", "ãƒ›ãƒ¼ãƒªãƒ¼", "ãƒ•ãƒ¬ã‚¤ãƒ ", "ã‚·ãƒ£ãƒ‰ã‚¦", "ãƒŸã‚¹ãƒ†ã‚£ãƒƒã‚¯", "ã‚·ãƒ«ãƒãƒ¼", "ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³", "ã‚¯ãƒªã‚¹ã‚¿ãƒ«"];
    const suffixes = ["ãƒŠã‚¤ãƒˆ", "ãƒ‰ãƒ©ã‚´ãƒ³", "ã‚¦ã‚£ã‚¶ãƒ¼ãƒ‰", "ãƒ•ã‚§ã‚¢ãƒªãƒ¼", "ã‚½ãƒ«ã‚¸ãƒ£ãƒ¼", "ãƒªãƒ¼ãƒ‘ãƒ¼", "ãƒ“ãƒ¼ã‚¹ãƒˆ", "ã‚¬ãƒ¼ãƒ‡ã‚£ã‚¢ãƒ³", "ãƒ¡ã‚¤ã‚¸", "ãƒ—ãƒªãƒ¼ã‚¹ãƒˆ"];
    const effects = ["none", "none", "none", "none", "none", "rush", "rush", "guard", "guard", "boost", "boost", "fanfare"];
    const effectDescriptions = {
      none: "åŠ¹æœãªã—",
      rush: "çªé€²: å ´ã«å‡ºãŸã‚¿ãƒ¼ãƒ³ã«æ”»æ’ƒå¯èƒ½",
      guard: "å®ˆè­·: ãƒ©ã‚¤ãƒ•ã‚„éå®ˆè­·ã‚«ãƒ¼ãƒ‰ã¸ã®æ”»æ’ƒã‚’ãƒ–ãƒ­ãƒƒã‚¯",
      boost: "ãƒ–ãƒ¼ã‚¹ãƒˆ: ãƒãƒˆãƒ«ã‚¨ãƒªã‚¢ã«å‡ºã¦ã„ã‚‹æ™‚ã€æ‰‹æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ã§ä½“åŠ›+1",
      fanfare: "ãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬: å ´ã«å‡ºãŸæ™‚ã€æ”»æ’ƒåŠ›+1"
    };

    const cardsData = [
      { id: 0, name: "ã‚¬ãƒ¼ãƒ‡ã‚£ã‚¢ãƒ³ãƒŠã‚¤ãƒˆ", class: "ã‚½ãƒ¼ãƒ‰ã‚¯ãƒ©ãƒ•ãƒˆ", cost: 3, attack: 3, health: 5, effect: "guard" },
      { id: 1, name: "ã‚¢ã‚¤ã‚¢ãƒ³ã‚¬ãƒ¼ãƒ‡ã‚£ã‚¢ãƒ³", class: "ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«", cost: 5, attack: 5, health: 7, effect: "guard" },
      { id: 2, name: "ãƒ›ãƒ¼ãƒªãƒ¼ã‚¦ã‚©ãƒ¼ãƒ‡ãƒ³", class: "ãƒãƒ´ãƒ³ã‚¯ãƒ©ãƒ•ãƒˆ", cost: 7, attack: 7, health: 9, effect: "guard" },
      ...Array.from({ length: 27 }, (_, i) => {
        const cost = Math.floor(i / 3) + 1;
        let attack, health;
        if (cost === 1) {
          attack = Math.floor(Math.random() * 2) + 1;
          health = Math.floor(Math.random() * 2) + 1;
        } else if (cost === 2) {
          attack = Math.floor(Math.random() * 2) + 2;
          health = attack + Math.floor(Math.random() * 2) + 1;
        } else if (cost === 3) {
          attack = Math.floor(Math.random() * 2) + 3;
          health = attack + Math.floor(Math.random() * 2) + 1;
        } else {
          attack = Math.max(1, Math.floor(cost * 1.0 + Math.random() * 3));
          health = attack + Math.floor(Math.random() * 4) + 2;
        }
        const effect = effects[Math.floor(Math.random() * effects.length)];
        return {
          id: i + 3,
          name: `${prefixes[Math.floor(Math.random() * prefixes.length)]}${suffixes[Math.floor(Math.random() * suffixes.length)]}`,
          class: classes[Math.floor(Math.random() * classes.length)],
          cost,
          attack,
          health,
          effect,
        };
      }),
    ];

    let playerHand = [];
    let playerField = [];
    let aiHand = [];
    let aiField = [];
    let playerMana = 1;
    let maxPlayerMana = 1;
    let aiMana = 1;
    let maxAiMana = 1;
    let playerLife = 20;
    let aiLife = 20;
    let currentTurn = "player";
    let turnCount = 1;
    let gameOver = false;
    let isMulliganPhase = true;
    let selectedCards = [];

    function initializeGame() {
      try {
        playerHand = drawCards(5);
        aiHand = drawCards(5);
        playerField = [];
        aiField = [];
        playerMana = 1;
        maxPlayerMana = 1;
        aiMana = 1;
        maxAiMana = 1;
        playerLife = 20;
        aiLife = 20;
        turnCount = 1;
        currentTurn = "player";
        gameOver = false;
        isMulliganPhase = true;
        selectedCards = [];
        document.getElementById("game-result").classList.remove("show");
        document.getElementById("mulligan-screen").classList.add("show");
        document.getElementById("card-detail-modal").classList.remove("show");
        updateMulliganDisplay();
        updateGameStatus();
        console.log(`ã‚²ãƒ¼ãƒ åˆæœŸåŒ– - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒãƒŠ: ${playerMana}/${maxPlayerMana}, AIãƒãƒŠ: ${aiMana}/${maxAiMana}, ãƒãƒªã‚¬ãƒ³é–‹å§‹`);
        console.log("ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿:", JSON.stringify(cardsData, null, 2));
      } catch (error) {
        console.error("ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function drawCards(num) {
      const hand = [];
      for (let i = 0; i < num; i++) {
        const randomCard = cardsData[Math.floor(Math.random() * cardsData.length)];
        hand.push({ ...randomCard, canAttack: false });
      }
      return hand;
    }

    function updateMulliganDisplay() {
      try {
        const mulliganCardsDiv = document.getElementById("mulligan-cards");
        mulliganCardsDiv.innerHTML = "";
        playerHand.forEach((card, index) => {
          const cardElement = document.createElement("div");
          cardElement.className = `card mulligan-card ${card.effect !== "none" ? "effect" : ""} ${selectedCards.includes(index) ? "selected" : ""} ${card.effect === "guard" ? "guard" : ""}`;
          cardElement.setAttribute("data-index", index);
          cardElement.innerHTML = `
            <div class="font-bold card-name">${card.name}</div>
            <div>ã‚¯ãƒ©ã‚¹: ${card.class}</div>
            <div>ã‚³ã‚¹ãƒˆ: ${card.cost}</div>
            <div>æ”»æ’ƒ: ${card.attack} / ä½“åŠ›: ${card.health}</div>
            <div class="tooltip" data-tooltip="${effectDescriptions[card.effect] || "åŠ¹æœãªã—"}">åŠ¹æœ: ${card.effect || "-"}</div>
          `;
          cardElement.addEventListener("click", () => handleMulliganCardClick(index));
          cardElement.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            showCardDetail(index);
          });
          mulliganCardsDiv.appendChild(cardElement);
        });
        console.log(`ãƒãƒªã‚¬ãƒ³è¡¨ç¤ºæ›´æ–° - é¸æŠã‚«ãƒ¼ãƒ‰: ${selectedCards.length > 0 ? selectedCards.map(i => playerHand[i].name).join(", ") : "ãªã—"}`);
      } catch (error) {
        console.error("ãƒãƒªã‚¬ãƒ³è¡¨ç¤ºã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function showCardDetail(index) {
      try {
        const card = playerHand[index];
        if (!card) {
          console.log("ã‚«ãƒ¼ãƒ‰è©³ç´°è¡¨ç¤ºå¤±æ•—: ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„", { index, playerHand });
          return;
        }
        const detailContent = document.getElementById("card-detail-content");
        detailContent.innerHTML = `
          <div class="font-bold text-xl mb-2">${card.name}</div>
          <div>ã‚¯ãƒ©ã‚¹: ${card.class}</div>
          <div>ã‚³ã‚¹ãƒˆ: ${card.cost}</div>
          <div>æ”»æ’ƒ: ${card.attack} / ä½“åŠ›: ${card.health}</div>
          <div>åŠ¹æœ: ${effectDescriptions[card.effect] || "åŠ¹æœãªã—"}</div>
        `;
        document.getElementById("card-detail-modal").classList.add("show");
        console.log(`ã‚«ãƒ¼ãƒ‰è©³ç´°è¡¨ç¤º: ${card.name}`);
      } catch (error) {
        console.error("ã‚«ãƒ¼ãƒ‰è©³ç´°è¡¨ç¤ºã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function handleMulliganCardClick(index) {
      try {
        if (selectedCards.includes(index)) {
          selectedCards = selectedCards.filter(i => i !== index);
          console.log(`ãƒãƒªã‚¬ãƒ³é¸æŠè§£é™¤: ${playerHand[index].name}`);
        } else {
          selectedCards.push(index);
          console.log(`ãƒãƒªã‚¬ãƒ³é¸æŠ: ${playerHand[index].name}`);
        }
        updateMulliganDisplay();
      } catch (error) {
        console.error("ãƒãƒªã‚¬ãƒ³é¸æŠã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function performMulligan() {
      try {
        if (selectedCards.length > 0) {
          console.log(`ãƒãƒªã‚¬ãƒ³å®Ÿè¡Œ - äº¤æ›ã‚«ãƒ¼ãƒ‰: ${selectedCards.map(i => playerHand[i].name).join(", ")}`);
          selectedCards.sort((a, b) => b - a);
          selectedCards.forEach(index => playerHand.splice(index, 1));
          playerHand.push(...drawCards(selectedCards.length));
        } else {
          console.log("ãƒãƒªã‚¬ãƒ³å®Ÿè¡Œ - äº¤æ›ãªã—");
        }
        isMulliganPhase = false;
        document.getElementById("mulligan-screen").classList.remove("show");
        updateGameDisplay();
        console.log("ãƒãƒªã‚¬ãƒ³å®Œäº† - ã‚²ãƒ¼ãƒ é–‹å§‹");
      } catch (error) {
        console.error("ãƒãƒªã‚¬ãƒ³å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function updateGameDisplay() {
      try {
        document.getElementById("game-status").textContent = `ã‚¿ãƒ¼ãƒ³: ${turnCount} (${currentTurn === "player" ? "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼" : "AI"})`;
        document.getElementById("player-mana").textContent = `ãƒãƒŠ: ${playerMana}/${maxPlayerMana}`;
        document.getElementById("player-life").textContent = `ãƒ©ã‚¤ãƒ•: ${playerLife}`;
        document.getElementById("ai-mana").textContent = `ãƒãƒŠ: ${aiMana}/${maxAiMana}`;
        document.getElementById("ai-life").textContent = `ãƒ©ã‚¤ãƒ•: ${aiLife}`;

        const playerCardsDiv = document.getElementById("player-cards");
        const playerFieldDiv = document.getElementById("player-field");
        const aiFieldDiv = document.getElementById("ai-field");

        playerCardsDiv.innerHTML = "";
        playerFieldDiv.innerHTML = "";
        aiFieldDiv.innerHTML = "";

        playerHand.forEach((card, index) => {
          const cardElement = createCardElement(card, index, "player-hand");
          playerCardsDiv.appendChild(cardElement);
        });

        playerField.forEach((card, index) => {
          const cardElement = createCardElement(card, index, "player-field");
          playerFieldDiv.appendChild(cardElement);
        });

        aiField.forEach((card, index) => {
          const cardElement = createCardElement(card, index, "ai-field");
          aiFieldDiv.appendChild(cardElement);
        });

        console.log(`è¡¨ç¤ºæ›´æ–° - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒãƒŠ: ${playerMana}/${maxPlayerMana}, AIãƒãƒŠ: ${aiMana}/${maxAiMana}, ãƒ©ã‚¤ãƒ• - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: ${playerLife}, AI: ${aiLife}`);
        console.log(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹æœ­:`, playerHand.map(c => c.name));
        console.log(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å ´ã‚«ãƒ¼ãƒ‰:`, playerField.map(c => ({ name: c.name, canAttack: c.canAttack, effect: c.effect })));
        console.log(`AIå ´ã‚«ãƒ¼ãƒ‰:`, aiField.map(c => ({ name: c.name, canAttack: c.canAttack, effect: c.effect })));
      } catch (error) {
        console.error("è¡¨ç¤ºæ›´æ–°ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function createCardElement(card, index, type) {
      try {
        const cardDiv = document.createElement("div");
        cardDiv.className = `card ${card.effect !== "none" ? "effect" : ""} ${type === "player-field" && card.canAttack && currentTurn === "player" && !gameOver && !isMulliganPhase ? "attackable" : ""} ${type === "player-field" && !card.canAttack ? "attacked" : ""} ${type === "ai-field" && currentTurn === "player" && !gameOver && !isMulliganPhase ? "drop-target" : ""} ${card.effect === "guard" ? "guard" : ""}`;
        cardDiv.setAttribute("data-index", index);
        cardDiv.setAttribute("data-type", type);
        if (type === "player-hand" && !isMulliganPhase || (type === "player-field" && card.canAttack && currentTurn === "player" && !gameOver && !isMulliganPhase)) {
          cardDiv.setAttribute("draggable", "true");
        }
        cardDiv.innerHTML = `
          <div class="font-bold">${card.name}</div>
          <div>ã‚¯ãƒ©ã‚¹: ${card.class}</div>
          <div>ã‚³ã‚¹ãƒˆ: ${card.cost}</div>
          <div>æ”»æ’ƒ: ${card.attack} / ä½“åŠ›: ${card.health}</div>
          <div class="tooltip" data-tooltip="${effectDescriptions[card.effect] || "åŠ¹æœãªã—"}">åŠ¹æœ: ${card.effect || "-"}</div>
        `;
        if (type === "player-hand" && !isMulliganPhase || (type === "player-field" && card.canAttack && currentTurn === "player" && !gameOver && !isMulliganPhase)) {
          cardDiv.addEventListener("dragstart", handleDragStart);
          cardDiv.addEventListener("dragend", handleDragEnd);
        }
        return cardDiv;
      } catch (error) {
        console.error("ã‚«ãƒ¼ãƒ‰ä½œæˆã‚¨ãƒ©ãƒ¼:", error.stack);
        return document.createElement("div");
      }
    }

    function handleDragStart(event) {
      try {
        if (gameOver || isMulliganPhase) {
          console.log(`ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹å¤±æ•—: ${gameOver ? "ã‚²ãƒ¼ãƒ çµ‚äº†ä¸­" : "ãƒãƒªã‚¬ãƒ³ä¸­"}`);
          return;
        }
        const index = event.target.getAttribute("data-index");
        const type = event.target.getAttribute("data-type");
        event.dataTransfer.setData("text/plain", JSON.stringify({ index: parseInt(index), type }));
        event.target.classList.add("dragging");
        console.log(`ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹: ${type}, ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: ${index}`);
      } catch (error) {
        console.error("ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function handleDragEnd(event) {
      try {
        event.target.classList.remove("dragging");
        console.log(`ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†: ${event.target.getAttribute("data-type")}, ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: ${event.target.getAttribute("data-index")}`);
      } catch (error) {
        console.error("ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function handlePlayDrop(event) {
      try {
        event.preventDefault();
        if (gameOver || isMulliganPhase) {
          console.log(`ãƒ—ãƒ¬ã‚¤ãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: ${gameOver ? "ã‚²ãƒ¼ãƒ çµ‚äº†ä¸­" : "ãƒãƒªã‚¬ãƒ³ä¸­"}`);
          return;
        }
        if (currentTurn !== "player") {
          console.log("ãƒ—ãƒ¬ã‚¤ãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã§ã¯ãªã„");
          return;
        }
        const data = JSON.parse(event.dataTransfer.getData("text/plain"));
        if (data.type !== "player-hand") {
          console.log("ãƒ—ãƒ¬ã‚¤ãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: æ‰‹æœ­ã‚«ãƒ¼ãƒ‰ã§ã¯ãªã„", { data });
          return;
        }
        const cardIndex = data.index;
        const card = playerHand[cardIndex];
        if (!card) {
          console.log("ãƒ—ãƒ¬ã‚¤ãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: ã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„", { cardIndex, playerHand });
          return;
        }
        if (playerMana < card.cost) {
          console.log(`ãƒ—ãƒ¬ã‚¤ãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: ãƒãƒŠä¸è¶³ (å¿…è¦: ${card.cost}, ç¾åœ¨: ${playerMana})`);
          return;
        }
        if (playerField.length >= 5) {
          console.log("ãƒ—ãƒ¬ã‚¤ãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: ãƒ—ãƒ¬ã‚¤ã‚¨ãƒªã‚¢ãŒæº€æ¯");
          return;
        }
        let newCard = { ...card, canAttack: card.effect === "rush" };
        if (card.effect === "fanfare") {
          newCard.attack += 1;
          console.log(`ãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬ç™ºå‹•: ${card.name}, æ”»æ’ƒåŠ›+1 -> ${newCard.attack}`);
        }
        playerField.push(newCard);
        playerMana -= card.cost;
        playerHand.splice(cardIndex, 1);
        playerField.forEach(fieldCard => {
          if (fieldCard && fieldCard.effect === "boost") {
            fieldCard.health += 1;
            console.log(`ãƒ–ãƒ¼ã‚¹ãƒˆç™ºå‹•: ${fieldCard.name}, ä½“åŠ›+1 -> ${fieldCard.health}`);
          }
        });
        updateGameDisplay();
        console.log(`ã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¬ã‚¤: ${card.name}, æ®‹ãƒãƒŠ: ${playerMana}, å ´ã‚«ãƒ¼ãƒ‰æ•°: ${playerField.length}`);
      } catch (error) {
        console.error("ãƒ—ãƒ¬ã‚¤ãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function handleAttackDrop(event) {
      try {
        event.preventDefault();
        if (gameOver || isMulliganPhase) {
          console.log(`æ”»æ’ƒãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: ${gameOver ? "ã‚²ãƒ¼ãƒ çµ‚äº†ä¸­" : "ãƒãƒªã‚¬ãƒ³ä¸­"}`);
          return;
        }
        if (currentTurn !== "player") {
          console.log("æ”»æ’ƒãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã§ã¯ãªã„");
          return;
        }
        const data = JSON.parse(event.dataTransfer.getData("text/plain"));
        if (data.type !== "player-field") {
          console.log("æ”»æ’ƒãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: å ´ã‚«ãƒ¼ãƒ‰ã§ã¯ãªã„", { data });
          return;
        }
        const cardIndex = data.index;
        const attackingCard = playerField[cardIndex];
        if (!attackingCard || !attackingCard.canAttack) {
          console.log(`æ”»æ’ƒãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: æ”»æ’ƒä¸å¯ ${attackingCard ? attackingCard.name : "ä¸æ˜"} (canAttack: ${attackingCard ? attackingCard.canAttack : "N/A"})`);
          return;
        }

        const hasGuard = aiField.some(card => card && card.effect === "guard");
        const target = event.target.closest("#ai-info") || event.target.closest(".card[data-type='ai-field']");
        if (!target) {
          console.log("æ”»æ’ƒãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: ç„¡åŠ¹ãªã‚¿ãƒ¼ã‚²ãƒƒãƒˆ");
          return;
        }

        if (target.id === "ai-info") {
          if (hasGuard) {
            console.log(`æ”»æ’ƒãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: AIå ´ã«Guardã‚«ãƒ¼ãƒ‰ãŒå­˜åœ¨ (${aiField.filter(c => c && c.effect === "guard").map(c => c.name).join(", ")})`);
            return;
          }
          aiLife -= attackingCard.attack;
          attackingCard.canAttack = false;
          updateGameDisplay();
          checkGameEnd();
          console.log(`ç›´æ¥æ”»æ’ƒ: ${attackingCard.name} -> AIãƒ©ã‚¤ãƒ•, ãƒ€ãƒ¡ãƒ¼ã‚¸: ${attackingCard.attack}, AIãƒ©ã‚¤ãƒ•æ®‹: ${aiLife}`);
        } else {
          const aiCardIndex = parseInt(target.getAttribute("data-index"));
          const aiCard = aiField[aiCardIndex];
          if (!aiCard) {
            console.log("æ”»æ’ƒãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: AIã‚«ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚‰ãªã„", { aiCardIndex, aiField });
            return;
          }
          if (hasGuard && aiCard.effect !== "guard") {
            console.log(`æ”»æ’ƒãƒ‰ãƒ­ãƒƒãƒ—å¤±æ•—: Guardã‚«ãƒ¼ãƒ‰ãŒå­˜åœ¨ã™ã‚‹ãŒã€${aiCard.name}ã¯Guardã§ã¯ãªã„`);
            return;
          }
          aiCard.health -= attackingCard.attack;
          attackingCard.health -= aiCard.attack;
          playerField = playerField.filter(card => card && card.health > 0);
          aiField = aiField.filter(card => card && card.health > 0);
          attackingCard.canAttack = false;
          updateGameDisplay();
          checkGameEnd();
          console.log(`ã‚«ãƒ¼ãƒ‰æ”»æ’ƒ: ${attackingCard.name} -> ${aiCard.name}, ãƒ€ãƒ¡ãƒ¼ã‚¸: ${attackingCard.attack}/${aiCard.attack}`);
        }
      } catch (error) {
        console.error("æ”»æ’ƒãƒ‰ãƒ­ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function handleEndTurn() {
      try {
        if (gameOver || isMulliganPhase) {
          console.log(`ã‚¿ãƒ¼ãƒ³çµ‚äº†å¤±æ•—: ${gameOver ? "ã‚²ãƒ¼ãƒ çµ‚äº†ä¸­" : "ãƒãƒªã‚¬ãƒ³ä¸­"}`);
          return;
        }
        if (currentTurn !== "player") {
          console.log("ã‚¿ãƒ¼ãƒ³çµ‚äº†å¤±æ•—: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³ã§ã¯ãªã„");
          return;
        }
        currentTurn = "ai";
        turnCount++;
        maxPlayerMana = Math.min(maxPlayerMana + 1, 10);
        playerHand.push(...drawCards(1));
        updateGameDisplay();
        console.log(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³çµ‚äº† - ã‚¿ãƒ¼ãƒ³: ${turnCount}, ãƒãƒŠ: ${playerMana}/${maxPlayerMana}`);
        startAiTurn();
      } catch (error) {
        console.error("ã‚¿ãƒ¼ãƒ³çµ‚äº†ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function startPlayerTurn() {
      try {
        playerMana = maxPlayerMana;
        playerField.forEach(card => {
          if (card) {
            card.canAttack = true;
            console.log(`æ”»æ’ƒå¯èƒ½ãƒªã‚»ãƒƒãƒˆ: ${card.name}, canAttack: ${card.canAttack}, effect: ${card.effect}`);
          }
        });
        updateGameDisplay();
        console.log(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³é–‹å§‹ - ãƒãƒŠ: ${playerMana}/${maxPlayerMana}`);
      } catch (error) {
        console.error("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ¼ãƒ³é–‹å§‹ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function startAiTurn() {
      try {
        console.log(`AIã‚¿ãƒ¼ãƒ³é–‹å§‹ - ãƒãƒŠ: ${aiMana}/${maxAiMana}`);
        aiMana = maxAiMana;
        aiField.forEach(card => {
          if (card) {
            card.canAttack = true;
            console.log(`AIæ”»æ’ƒå¯èƒ½ãƒªã‚»ãƒƒãƒˆ: ${card.name}, canAttack: ${card.canAttack}, effect: ${card.effect}`);
          }
        });
        const playableCards = aiHand.filter(card => card && aiMana >= card.cost && aiField.length < 5);
        if (playableCards.length > 0) {
          const card = playableCards[Math.floor(Math.random() * playableCards.length)];
          let newCard = { ...card, canAttack: card.effect === "rush" };
          if (card.effect === "fanfare") {
            newCard.attack += 1;
            console.log(`AIãƒ•ã‚¡ãƒ³ãƒ•ã‚¡ãƒ¼ãƒ¬ç™ºå‹•: ${card.name}, æ”»æ’ƒåŠ›+1 -> ${newCard.attack}`);
          }
          aiField.push(newCard);
          aiMana -= card.cost;
          const cardIndex = aiHand.findIndex(c => c && c.id === card.id && c.cost === card.cost);
          if (cardIndex !== -1) {
            aiHand.splice(cardIndex, 1);
          }
          aiField.forEach(fieldCard => {
            if (fieldCard && fieldCard.effect === "boost") {
              fieldCard.health += 1;
              console.log(`AIãƒ–ãƒ¼ã‚¹ãƒˆç™ºå‹•: ${fieldCard.name}, ä½“åŠ›+1 -> ${fieldCard.health}`);
            }
          });
          console.log(`AIã‚«ãƒ¼ãƒ‰ãƒ—ãƒ¬ã‚¤: ${card.name}, æ®‹ãƒãƒŠ: ${aiMana}, å ´ã‚«ãƒ¼ãƒ‰æ•°: ${aiField.length}`);
        }
        aiField.forEach((card, index) => {
          if (card && card.canAttack) {
            const hasGuard = playerField.some(c => c && c.effect === "guard");
            let targetCard;
            if (hasGuard) {
              const guardCards = playerField.filter(c => c && c.effect === "guard");
              targetCard = guardCards[Math.floor(Math.random() * guardCards.length)];
              console.log(`AIæ”»æ’ƒå¯¾è±¡åˆ¶é™: Guardã‚«ãƒ¼ãƒ‰ (${guardCards.map(c => c.name).join(", ")})`);
            } else if (playerField.length > 0 && Math.random() > 0.5) {
              targetCard = playerField[Math.floor(Math.random() * playerField.length)];
            }
            if (targetCard) {
              targetCard.health -= card.attack;
              card.health -= targetCard.attack;
              card.canAttack = false;
              console.log(`AIã‚«ãƒ¼ãƒ‰æ”»æ’ƒ: ${card.name} -> ${targetCard.name}, ãƒ€ãƒ¡ãƒ¼ã‚¸: ${card.attack}/${targetCard.attack}`);
            } else {
              playerLife -= card.attack;
              card.canAttack = false;
              console.log(`AIç›´æ¥æ”»æ’ƒ: ${card.name} -> ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ©ã‚¤ãƒ•, ãƒ€ãƒ¡ãƒ¼ã‚¸: ${card.attack}, ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ©ã‚¤ãƒ•æ®‹: ${playerLife}`);
            }
          }
        });
        playerField = playerField.filter(card => card && card.health > 0);
        aiField = aiField.filter(card => card && card.health > 0);
        aiHand.push(...drawCards(1));
        maxAiMana = Math.min(maxAiMana + 1, 10);
        currentTurn = "player";
        updateGameDisplay();
        checkGameEnd();
        startPlayerTurn();
      } catch (error) {
        console.error("AIã‚¿ãƒ¼ãƒ³ã‚¨ãƒ©ãƒ¼:", error.stack);
        currentTurn = "player";
        updateGameDisplay();
        startPlayerTurn();
      }
    }

    function checkGameEnd() {
      try {
        if (gameOver) return;
        const resultDiv = document.getElementById("game-result");
        const resultText = document.getElementById("result-text");
        if (playerLife <= 0 && aiLife > 0) {
          gameOver = true;
          resultText.textContent = "AIã®å‹åˆ©ï¼";
          resultDiv.classList.add("show");
          console.log("ã‚²ãƒ¼ãƒ çµ‚äº†: AIã®å‹åˆ©");
        } else if (aiLife <= 0 && playerLife > 0) {
          gameOver = true;
          resultText.textContent = "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹åˆ©ï¼";
          resultDiv.classList.add("show");
          console.log("ã‚²ãƒ¼ãƒ çµ‚äº†: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹åˆ©");
        } else if (playerLife <= 0 && aiLife <= 0) {
          gameOver = true;
          resultText.textContent = "å¼•ãåˆ†ã‘ï¼";
          resultDiv.classList.add("show");
          console.log("ã‚²ãƒ¼ãƒ çµ‚äº†: å¼•ãåˆ†ã‘");
        }
      } catch (error) {
        console.error("ã‚²ãƒ¼ãƒ çµ‚äº†ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function updateGameStatus() {
      try {
        document.getElementById("game-status").textContent = `ã‚¿ãƒ¼ãƒ³: ${turnCount} (${currentTurn === "player" ? "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼" : "AI"})`;
      } catch (error) {
        console.error("ã‚²ãƒ¼ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    function setupEventListeners() {
      try {
        const playArea = document.getElementById("play-area");
        const aiInfo = document.getElementById("ai-info");
        const aiField = document.getElementById("ai-field");
        const endTurnButton = document.getElementById("end-turn");
        const resetButton = document.getElementById("reset-button");
        const mulliganConfirmButton = document.getElementById("mulligan-confirm");
        const closeDetailButton = document.getElementById("close-detail");

        if (!playArea || !aiInfo || !aiField || !endTurnButton || !resetButton || !mulliganConfirmButton || !closeDetailButton) {
          throw new Error("å¿…è¦ãªDOMè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: " + JSON.stringify({
            playArea: !!playArea,
            aiInfo: !!aiInfo,
            aiField: !!aiField,
            endTurnButton: !!endTurnButton,
            resetButton: !!resetButton,
            mulliganConfirmButton: !!mulliganConfirmButton,
            closeDetailButton: !!closeDetailButton
          }, null, 2));
        }

        playArea.addEventListener("dragover", event => event.preventDefault());
        playArea.addEventListener("drop", handlePlayDrop);
        aiInfo.addEventListener("dragover", event => event.preventDefault());
        aiInfo.addEventListener("drop", handleAttackDrop);
        aiField.addEventListener("dragover", event => event.preventDefault());
        aiField.addEventListener("drop", handleAttackDrop);

        endTurnButton.removeEventListener("click", handleEndTurn);
        endTurnButton.addEventListener("click", handleEndTurn);

        resetButton.removeEventListener("click", initializeGame);
        resetButton.addEventListener("click", initializeGame);

        mulliganConfirmButton.removeEventListener("click", performMulligan);
        mulliganConfirmButton.addEventListener("click", performMulligan);

        closeDetailButton.removeEventListener("click", () => document.getElementById("card-detail-modal").classList.remove("show"));
        closeDetailButton.addEventListener("click", () => {
          document.getElementById("card-detail-modal").classList.remove("show");
          console.log("ã‚«ãƒ¼ãƒ‰è©³ç´°ãƒ¢ãƒ¼ãƒ€ãƒ«é–‰ã˜ã‚‹");
        });

        console.log("ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šå®Œäº†");
      } catch (error) {
        console.error("ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      try {
        initializeGame();
        setupEventListeners();
        console.log("DOMContentLoaded: ã‚²ãƒ¼ãƒ åˆæœŸåŒ–ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®šå®Œäº†");
      } catch (error) {
        console.error("DOMContentLoadedã‚¨ãƒ©ãƒ¼:", error.stack);
      }
    });
  </script>
</body>
</html>